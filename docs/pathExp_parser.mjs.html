<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: pathExp/parser.mjs</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: pathExp/parser.mjs</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//@ts-check

import { ParsingError, isWhitespace } from "../utils.mjs"

import {
  AnyMatcher,
  SegmentMatcher,
  SliceMatcher,
  MatcherContainer,
} from "./matcher.mjs"

const STATE = {
  VALUE: "VALUE",
  STRING_SINGLE_QUOTE: "STRING_SINGLE_QUOTE",
  STRING_DOUBLE_QUOTE: "STRING_DOUBLE_QUOTE",
  NUMBER_OR_SLICE: "NUMBER_OR_SLICE",
  COMMENT: "COMMENT",
}

/**
 * parse and include expression and return a Matcher
 * @param {string} str - the include expression
 * @return {MatcherContainer}
 */
function parseIncludes(str) {
  str += " " // this simplifies parsing of numbers (the extra space act as a delimiter)
  const matcherStack = [new MatcherContainer()]
  const getLastMatcherChildren = () =>
    matcherStack[matcherStack.length - 1].matchers

  let state = STATE.VALUE
  let stringBuffer = ""
  for (let index = 0; index &lt; str.length; index++) {
    const char = str[index]
    switch (state) {
      case STATE.VALUE:
        if (isWhitespace(char)) continue
        if (char === "(") {
          // add last matcher to the stack
          const lastMatcherChildren = getLastMatcherChildren()
          matcherStack.push(lastMatcherChildren[lastMatcherChildren.length - 1])
        } else if (char === ")") {
          // remove last matcher from the stack
          matcherStack.pop()
          if (matcherStack.length === 0) {
            throw new ParsingError("Unpaired brackets: ", index)
          }
        } else if (char === "*") {
          getLastMatcherChildren().push(new AnyMatcher())
        } else if (char === '"') {
          state = STATE.STRING_DOUBLE_QUOTE
          stringBuffer = ""
        } else if (char === "'") {
          state = STATE.STRING_SINGLE_QUOTE
          stringBuffer = ""
        } else if (/[0-9\.]/.test(char)) {
          state = STATE.NUMBER_OR_SLICE
          stringBuffer = char
        } else if (char === "#") {
          state = STATE.COMMENT
        } else {
          throw new ParsingError("Unknown token: " + char, index)
        }
        continue
      case STATE.COMMENT:
        if (char === "\n") {
          state = STATE.VALUE
        }
        continue
      case STATE.STRING_SINGLE_QUOTE:
        if (char === "'") {
          getLastMatcherChildren().push(new SegmentMatcher(stringBuffer))
          state = STATE.VALUE
        } else {
          stringBuffer += char
        }
        continue
      case STATE.STRING_DOUBLE_QUOTE:
        if (char === '"') {
          getLastMatcherChildren().push(new SegmentMatcher(stringBuffer))
          state = STATE.VALUE
        } else {
          stringBuffer += char
        }
        continue

      case STATE.NUMBER_OR_SLICE:
        if (!/[0-9\.]/.test(char)) {
          if (stringBuffer.includes("..")) {
            const minAndMax = stringBuffer.split("..")
            if (minAndMax.length !== 2) {
              throw new ParsingError("Invalid slice: " + state, index)
            }
            const min = minAndMax[0].length !== 0 ? parseInt(minAndMax[0]) : 0
            const max =
              minAndMax[1].length !== 0 ? parseInt(minAndMax[1]) : Infinity
            getLastMatcherChildren().push(new SliceMatcher({ min, max }))
          } else if (/[0-9]+/.test(stringBuffer)) {
            getLastMatcherChildren().push(
              new SegmentMatcher(parseInt(stringBuffer)),
            )
          } else {
            throw new ParsingError("Invalid index: " + state, index)
          }
          state = STATE.VALUE
          index--
        } else {
          stringBuffer += char
        }
        continue
      default:
        throw new ParsingError("Unknown state: " + state, index)
    }
  }
  return matcherStack[0]
}

export default parseIncludes
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="MatcherContainer.html">MatcherContainer</a></li><li><a href="ObjectToSequence.html">ObjectToSequence</a></li><li><a href="PathConverter.html">PathConverter</a></li><li><a href="SequenceToObject.html">SequenceToObject</a></li><li><a href="SequenceToStream.html">SequenceToStream</a></li><li><a href="StreamToSequence.html">StreamToSequence</a></li></ul><h3>Global</h3><ul><li><a href="global.html#parseIncludes">parseIncludes</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Jan 11 2025 17:37:45 GMT+0000 (Greenwich Mean Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
